#垃圾回收算法

* 引用计数法

        任何引用计数器为0的对象实例可以被当作垃圾收集。
        当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。
        缺点：
        
        无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.
        
* 标记清除法(标记的是存活对象)
    * 根扫描(GC Root)
        1. 虚拟机栈中引用的对象（本地变量表）
        2. 方法区中静态属性引用的对象     
        3. 方法区中常量引用的对象        
        4. 本地方法栈中引用的对象（Native对象）
* 标记整理法
    * 在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。
* 复制算法
    * 耗费空间 将内存分为存活对象区和空闲区，移动存活对象
* ZGC染色标记法 对指针标记，三种状态

# 垃圾收集器
* 新生代(复制算法)收集器使用的收集器：Serial、PraNew、Parallel Scavenge

* 老年代(标记整理)收集器使用的收集器：Serial Old、Parallel Old、CMS
 ![avatar](gc.jpg)
 
* CMS(Concurrent Mark Sweep)收集器（标记-清理算法）
    高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择 

# FULL GC
1. 年老代（Tenured）被写满
2. 持久代（Perm）被写满
3. System.gc()被显示调用
4. 上一次GC之后Heap的各域分配策略动态变化