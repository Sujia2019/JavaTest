classloader

classInfo 堆对象
锁标识     指向方法区的类


class c = Class.forName("xxx")
堆里 
全局hashmap   k(xxx) v(classInfo)





可共享可排他是乐观锁     share unit
悲观锁-----慢在调度和加载缓存
锁三步升级法----不上锁(开逃逸分析)    锁是可以偏向的
              自旋锁
              中断锁



数据库引擎

所有数据库的底层都是文件系统
        


         MS(管理系统)
            /\      你在查找的时候根据索引查找时是range 根据b+树，不然就全表遍历了
            /\            聚集索引(mysql根据主键构建聚集索引)
           sql  
            /\
            /\
        sql解释器
            /\
            /\
    集合操作api(filter,map,reduce,sort)
            /\
            /\
      rdb  关系对象层
            /\
            /\
在linux的文件系统上封一个文件格式(k,v)   对外封装api
                            `   (put,get,remove,)

sql 是对集合的处理
优化sql的方法：
0、加索引(加索引的问题是查快了，写慢了，因为要倒腾那棵树) elasticsearch+mysql
                                     让elasticearch做最新的数据，mysql做最终数据
        优化 空间换时间，做两份数据，一份普通的数据，一份是索引树
                       出现问题：一致性问题！
1、小范围join大范围，中间结果尽量小
2、先出小集合 再大集合



缓存：
1、sql解析结果集缓存    同一sql统一缓存 select * from where id=? 这个sql的结构不变，只是数变了
2、最终结果缓存          select * from where id>10   整个的这个句子都没变，缓存最终结果集，没啥用，因为表数据一直在变，顶多做一个结果报表用
3、中间结果缓存    select * from x1 join x2.....查的x2就属于一个中间结果缓存

mysql引擎
memory   全内存 (悲观 表锁)
myisam   内存映射文件(表锁 很像swap按内存结构存到硬盘了)
innodb   文件(聚集索引 表锁)

咱们的数据库：ACID 隔离性 持久性(索引) 原子性(事务，关系) 一致性(多版本多事务并发控制)

事务 隔离级别
begin   事务开启
commit  事务结束

脏读       (效率快，但错误率高)
幻读       (另一个事务commit的时候出现了幻觉。。)
可重复读    我的事务跟别人的事务互不干扰，当事务结束后，再查是可以保证真实的。mysql默认
串行化      锁死了



Spring事务传递级别


熔断和限流
熔断直接让一部分人死掉，进不去
限流是一部分人访问没问题，另一部分太卡了进不去，别人会以为是网速问题

降级------一致性哈希   哈希环

k8s


















