1、用户区（process buffer）   内核区(buffer有可能已存在进程，process 请求)        disk       DMA(存储访问控制器)--->数据写入内核buffer---->用户取数据进入process buffer
2、虚拟内存：物理机一部分代替内存RAM,让多个虚拟地址映射到RAM同一个地址上;一个虚拟内存可以大于实际内存
3、文件系统IO：CPU上下文切换 CONTEXT（关于CPU：1上下文切换，linux把多核当作多个单核，普通CPU用时间片论寻.2运行队列，.3使用域指标）
                                                                                                                                        方向：内存到硬盘（输出）
JVM   ---|catch缓存区域（存取数据时将数据放入catch中方便下一次存取以便直接调用）    |--->           DB
抽象基类
String s=File.speartor
HOMEWORK1: String buffer\string builder\string 区别
JSON： 
           {"a":1,"b":2}锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程
   数组    ["a","b","c"]
   组合内嵌{"a":[1,,2,3],"b":{"c":1}}
   List<MAp<String.Object>>list------转JSON---->[{"a":1,"b":"fffff"},{},{}]
  
NIO
Non-blocking in out//非阻塞IO
      实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现{
           方法一：（java1.2之前）使用用户线程实现 
                   优点：线程实现在用户空间下,系统内核不能感知线程存在的实现,用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助,非常快速且低消耗的，也可以支持规模更大的线程数量
		   缺点：所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程
           方法二： 线程实现在操作系统内核中
 这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的 内核就叫做多线程内核。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持
           方法三：使用用户线程加轻量级进程混合实现
    既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系
       }
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-
锁(只在一个JVM中生效)
    偏向锁：锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程，在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步，退出同步也，无需每次加锁解锁都去CAS更新对象头，如果不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候需要锁膨胀为轻量级锁，才能保证线程间公平竞争锁。
    自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，线程不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。


















————————————————————————————————————————————————————————————————————
分布式锁
setnx 1 expire 1000

putMaPEn

ConcurrentHashMap

内存屏障
