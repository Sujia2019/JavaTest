java环境变量原理
  stringbuffer//线程安全
  stringbuilder//速度更快
  suffle
java内存结构{
  运行时数据区{      
	程序计数器（每条线程有独立的程序计数器，在线程私有内存中）{
           作用：当前线程所执行字节吗行号指示器（字节码解释器工作：改变计数器值选取下一条需要执行的字节码）
	}
        虚拟机栈  ->栈帧{
            为虚拟机执行java方法（字节码）服务
	    java虚拟机规范定义的两种异常：{
	     1、StackOverflowError:线程请求的栈深度大于虚拟机所允许的深度
             2、OutOfMemoryError:虚拟机栈可以动态扩展无法申请足够的内存时抛出
          }
        }
        本地方法栈{
	    为虚拟机使用的Native方法服务
                      （私有对象空间）
        }
        堆(垃圾回收机制作用范围GC堆){
            作用：存放对象实例、数组（栈上分配、标量替换优化技术、逃逸分析技术等使对象不全在堆中）
            细分：{
                新生代
                老年代
                Eden空间
                From Survivor空间
                To Survivor空间
             }
	    内存分配角度：有多个线程私有分配缓冲区
            
        }
        方法区（非堆）{
	    作用：存储别虚拟机加载的类信息、常量、静态变量
                   （多线程共享空间）
        }
  }
  |局部变量表 |
  |           |
  |操作数栈   |栈帧数据区（保存访问常量池指针）
  |           |异常处理表     
  ————————————
}
                                                 字面量
                                                 符号引用
主动引用：静态调用，反射，main方法，
     引用：强引用 Object obj=new Object()、(只要强引用还在垃圾回收不会回收引用的对象)
           软引用 SoftReference sr = new SoftReference()、(系统内存即将溢出前，才会被列为第二次回收范围，若回收后依旧无足够内存则发生溢出)
           弱引用 WeakReference wr = new WeakReference()、（被引用对象只能存活到下一次垃圾回收之前）
           虚引用PhantomReference pr = new PhantoReference()、（无法通过虚引用获得对象实例，为一个对象设置虚引用关联在于这个对象被回收时收到一个系统通知）
  类启动加载器（）、拓展类加载器（jvm提供自动扩展）、应用程序加载器（）、自定义类加载器
  双亲委派模式：{
     工作原理：当一个类加载器收到类加载的请求，它将这个加载请求委派给父类加载器进行加载，每一层加载器都是如此，最终，所有的请求都会传送到启动类加载器中。只有当父类加载器自己无法完成加载请求时，子类加载器才会尝试自己加载。
     双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。
     双亲委派模型可以确保安全性，经过不同加载器进行加载的类是无法访问彼此的。
	
  }
指针碰撞（无内存碎片，用过的内存全部整合一边），空闲列表（取决于java内存数否规整）
Minor GC
-XX:MaxTenurint The
可达性分析算法{
    垃圾收集算法：标记——清除算法
                 复制算法
		 标记——整理
                 分代收集算法
    根搜索算法：{               GC Roots              
                                   |
                                   |
                                object1                                 object5
                                 /    \                                  /  \
                                /      \                                /    \
                            object2    object3                    object6    object7
                                         |
                                         |
                                       object4
                            仍然存活的对象                             判定可回收的对象
  对象在进行根搜索发现没有与GCRoots相连的引用链后被第一次标记并进行一次筛选，筛选有无必要执行finalize()方法（）
  有必要执行finalize()方法的对象加入F-Queue队列
 
 
    }
    垃圾收集器：{
       「Serial收集器(串型)：所有工作线程暂停直到其回收完毕;
       \ParNew收集器：多线程并发应用暂停，
       \Parallel Scavenge收集器：
       \CMS：初始标记，并发标记，重新标记，并发清理，并发重置
       \G1」收集器：并行于并发、分代收集、空间整合、可预测的停顿
     }
  CAS+失败重试 compare and swap
  TLAB:Thread local allocation buffer

}
对象头、实例数据、对齐填充    （HotSpot虚拟机
对象的访问定位：（本地变量表）-->（Java堆：到对象类型数据的指针）-->（方法区）对象类型数据  直接指针访问
               
               （句柄）堆中有指向真正对象的指针：
      本地变量表 -->句柄池（到对象实例指针）----------->对象实际数据（实例池）
                         （堆中有指向真正对象的指针）-->对象类型数据（方法区）

————————————————————————————————————————————————————————————————————————————————————————————————————

处于激活状态的线程
栈中的某个对象
通过加载进的对象，可作为GCroots
java创建对象过程：{
   JVM首先对符号引用进行解析，如果找不到对应的符号引用，那么这个类还没有被加载，因此JVM便会进行类加载过程
   符号引用解析完毕之后，JVM会为对象在堆中分配内存，HotSpot虚拟机实现的JAVA对象包括三个部分：对象头、实例字段和对齐填充字段
   对象分配完堆内存之后，JVM会将该内存（除了对象头区域）进行零值初始化
   调用init方法
  }
  堆内存---->存在时间长的对象从新生代进入老年代
       ----->对于较大的对象直接进入老年代
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————-------




















